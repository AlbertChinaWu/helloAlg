# 小结

- 数组和链表是两种基本数据结构，分别代表数据在计算机内存中的连续空间存储和离散空间存储方式。两者的优缺点呈现出互补的特性。
- 数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。
- 链表通过更改指针实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、循环链表、双向链表。
- 动态数组，又称列表，是基于数组实现的一种数据结构。它保留了数组的优势，同时可以灵活调整长度。列表的出现极大地提高了数组的易用性，但可能导致部分内存空间浪费。
- 下表总结并对比了数组与链表的各项特性。

<div class="center-table" markdown>

|              | 数组                     | 链表         |
| ------------ | ------------------------ | ------------ |
| 存储方式     | 连续内存空间             | 离散内存空间 |
| 数据结构长度 | 长度不可变               | 长度可变     |
| 内存使用率   | 占用内存少、缓存局部性好 | 占用内存多   |
| 优势操作     | 随机访问                 | 插入、删除   |

</div>

!!! note "缓存局部性"

    在计算机中，数据读写速度排序是“硬盘 < 内存 < CPU 缓存”。当我们访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。链表则不然，计算机只能挨个地缓存各个节点，这样的多次“搬运”降低了整体效率。

- 下表对比了数组与链表在各种操作上的效率。

<div class="center-table" markdown>

| 操作     | 数组   | 链表   |
| ------- | ------ | ------ |
| 访问元素 | $O(1)$ | $O(N)$ |
| 添加元素 | $O(N)$ | $O(1)$ |
| 删除元素 | $O(N)$ | $O(1)$ |

</div>


## Q & A

!!! question "数组插入元素的代码中$i$是不是应该从$size$开始循环呢？如果从$size-1$开始循环,原来数组中最后一个元素是不是就丢失了？"

    是的，在不扩容的情况下，插入元素必然会导致数组末尾元素的丢失。

!!! question "数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？"

    栈内存分配由编译器自动完成，而堆内存由程序员在代码中分配（请注意这里的栈和堆不是数据结构中的栈和堆）。

    1. 栈不灵活，分配的内存大小不可更改；堆相对灵活，可以动态分配内存；
    2. 栈是一块比较小的内存，容易出现内存不足；堆内存很大，但是由于是动态分配，容易碎片化，管理堆内存的难度更大、成本更高；
    3. 访问栈比访问堆更快，因为栈内存较小、对缓存友好，堆帧分散在很大的空间内，会出现更多的缓存未命中；

!!! question "为什么数组会强调“相同类型的元素”，而在链表中却没有强调同类型呢"

    链表由结点组成，结点之间由指针连接，各个结点可以存储不同类型的数据，例如 int, double, string, object...
    相对地，编程语言规定数组元素必须是相同类型的，这样才能通过计算偏移量来获取对应元素位置。比如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 bytes 和 8 bytes ，那么此时就不能用以下公式计算偏移量了，因为数组中包含了两种 $elementLength$ 。
    // 元素内存地址 = 数组内存地址 + 元素长度 * 元素索引
    elementAddr = firtstElementAddr + elementLength * elementIndex

!!! question "如果定义一个结构体指针，我的理解应该是 $struct ListNode *next$; 为什么LeetCode上和这里的实现都没有$struct$关键字呢？"

    不用加的，因为那是在初始化一个变量。另外，在 c++/c/go 中，我们一般使用 $struct$ 结构体来声明实体类。
    以 C++ 举例，链表结构体的定义如下：
    ```
    /* 链表节点结构体 */
    struct ListNode {
    int val;         // 节点值
    ListNode *next;  // 指向下一节点的指针（引用）
    ListNode(int x) : val(x), next(nullptr) {}  // 构造函数
    };
    ```
    我们将其写成 $class$ 的形式如下，在 C++ 的 $class$ 里成员变量默认 $private$，因此我们需要声明为$public$
    ```
    class ListNode {
    public:
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
    };
    ```

!!! question "删除节点后，是否需要把 $P.next$ 设为 $None$ 呢"
    
    不修改 P.next 也可以。从该链表的角度看，从头结点遍历到尾结点已经遇不到 P 了，即意味着结点 P 已经从链表中删除，而结点 P 指向哪里无所谓。

!!! question "链表的插入和删除确实是$O(1)$，但是查找既然是需要遍历。那为什么不是$O(n)$呢？"
    
    是的，只做一次插入和删除操作时间复杂度是$O(n)$，一般来说链表插入删除操作讨论的是大量插入和删除数据。如果是先查找元素、再删除元素，那么是$O(n)$。但是这种只是一种特例，链表的 $O(1)$ 插入与删除在其他应用上可以得到体现，比如「双向队列」适合使用链表实现，有指针（变量）始终指向头结点、尾结点，每次插入、删除都是 $O(1)$ 。

!!! question "图片“链表定义与存储方式”中，浅蓝色的存储结点指针是占用一块内存地址吗？还是和结点值各占一半呢？"

    文中只是一个示意图，只是定性表示，没有定量。如果考虑定量的话，需要分情况：
    不同类型的结点值占用的空间是不同的，比如 int, long, double, 或者是类的实例等等。
    指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定，大多为 8 字节或 4 字节。

!!! question "如果创建多线程，并发的情况下，对同一个List操作，程序怎么判断size的执行顺序"

    多线程操作同一块内存应该是需要线程锁的，为了避免线程冲突，正常情况下所有对这个list的增删查改操作都需要在当前线程获取到了对这个list的控制权的情况下进行，因为size函数是对list的一个读取操作，所以执行size函数的顺序应该就是取决于哪个线程先获取到控制权，就先执行哪个线程中的size，也就是first come first serve（先到先得）了。

!!! question "在列表末尾添加元素是不是也不严格为 $O(1)$，比如某些情况下列表正好需要先扩容再添加，这时候时间复杂度就会是$O(N)$。请问Python中的$list$是否也会存在这种问题？"
    
    是的，遇到需要扩容时，系统会申请一块新的内存，并将原列表的所有元素搬运过去，此时会很慢。Python 也一样，应该没有语言能避开这个问题。

!!! question "“列表的出现大大提升了数组的实用性，但副作用是会造成部分内存空间浪费”,这里的”部分内存空间浪费“是指额外增加的变量如容量、长度、扩容倍数所占的内存吗？"

    是的，但更主要是因为 1.列表都会设定一个初始长度，我们不一定需要用这么多；2.为了防止频繁扩容，扩容一般都会乘以一个系数，比如 *1.5 。这样一来，也会出现很多空位，我们一般不会正正好好填满它们。