# 图

「图 Graph」是一种非线性数据结构，由「顶点 Vertex」和「边 Edge」组成。我们可将图 $G$ 抽象地表示为一组顶点 $V$ 和一组边 $E$ 的集合。例如，以下表示一个包含 5 个顶点和 7 条边的图

$$
\begin{aligned}
V & = \{ 0, 1, 2, 3, 4 \} \newline
E & = \{ (0,1), (0,2), (0,3), (1,2), (2,3), (2,4), (3,4) \} \newline
G & = \{ V, E \} \newline
\end{aligned}
$$

（图）

那么，图与其他数据结构的关系是什么？考虑把「顶点」看作结点，把「边」看作连接各个结点的指针，从而可将「图」看成一种基于「链表」拓展而来的数据结构。**相比线性关系（链表）和分治关系（树），网络关系（图）的自由度更高，也从而更为复杂**。

图在生活中处处可见，可以用来建模许多现实中的系统，并将各种实际问题越化为图计算问题。

|          | 顶点 | 边                   | 图计算问题   |
| -------- | ---- | -------------------- | ------------ |
| 社交网络 | 用户 | 好友关系             | 潜在好友推荐 |
| 地铁线路 | 站点 | 站点间的连通性       | 最短路线推荐 |
| 太阳系   | 星体 | 星体间的万有引力作用 | 行星轨道计算 |

## 图常见类型

根据边是否有向，图可分为「无向图 Undirected Graph」和「有向图 Directed Graph」。

- 在无向图中，边没有方向，表示两结点之间“双向”的连接关系，例如微信或 QQ 中的“好友关系”；
- 在有向图中，边是有方向的，$A \rightarrow B$ 和 $A \leftarrow B$ 两个方向的边是相互独立的，例如微博或抖音上的“关注”与“被关注”关系；

（图）

根据连接程度，图可分为「连通图 Connected Graph」和「非连通图 Disconnected Graph」。

- 对于连通图，从某个结点出发，可以到达其余任意结点；
- 对于非连通图，从某个结点出发，至少有一个结点无法到达；

（图）

我们可以给边添加“权重”变量，形成「有权图 Weighted Graph」。例如，在王者荣耀等游戏中，系统会根据共同游戏时间来计算玩家之间的“亲密度”，这种亲密度网络就可以使用有权图来表示。

（图）

## 图常用术语

- 「邻接 Adjacency」：当两顶点之间有边相连时，称此两顶点是邻接的。
- 「路径 Path」：从顶点 A 到顶点 B 走过的边构成的序列，被称为从 A 到 B 的路径。
- 「度 Degree」表示一个顶点具有多少条边。对于有向图，「入度 In-Degree」表示有多少条边指向该顶点，「出度 Out-Degree」表示有多少条边从该顶点指出。

## 图的表示

图的常用表示方法有两种。

### 邻接矩阵

设图的顶点数量为 $n$ ，「邻接矩阵 Adjacency Matrix」使用一个 $n \times n$ 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表顶点之间的边，使用 $1$ / $0$ 来分别表示两个顶点之间有 / 无边。

（图）

「无向图」的边是无方向的，因此对于任意 $i, j \in [0, n)$ ，一定有 $mat[i][j] = mat[j][i]$ ，即邻接矩阵关于主对角线对称。

使用邻接矩阵表示图时，我们可以直接通过访问矩阵元素来获取边，因此增删查操作的效率很高，时间复杂度均为 $O(1)$ 。然而，矩阵的空间复杂度为 $O(n^2)$ ，内存占用较大。

### 邻接表

「邻接表 Adjacency List」使用 $n$ 个链表来表示图，链表结点表示顶点。第 $i$ 条链表对应顶点 $i$ ，其中存储了所有与该顶点相连的顶点。

（图）

邻接表仅存储存在的边，而边的总数往往远小于 $n^2$ ，因此更加节省空间。但是，因为在邻接表中需要通过遍历链表来查找边，所以其时间效率不如邻接矩阵。

观察上图发现，**邻接表结构与哈希表「链地址法」非常相似，因此我们也可以用类似的方法来优化效率**。比如，当链表较长时，可以把链表转化为「AVL 树」，从而将时间效率从 $O(n)$ 优化至 $O(\log n)$ ，还可以通过中序遍历获取有序序列；还可以将链表转化为 HashSet（即哈希表），将时间复杂度降低至 $O(1)$ ，。

### 效率对比

设图中共有 $n$ 个顶点和 $m$ 条边，下表总结对比了邻接矩阵和邻接表的时间和空间效率。

|              | 邻接矩阵 | 邻接表（链表） | 邻接表（哈希表） |
| ------------ | -------- | -------------- | ---------------- |
| 判断是否邻接 | $O(1)$   | $O(m)$         | $O(1)$           |
| 添加边       | $O(1)$   | $O(1)$         | $O(1)$           |
| 删除边       | $O(1)$   | $O(m)$         | $O(1)$           |
| 添加顶点     | $O(n)$   | $O(1)$         | $O(1)$           |
| 删除顶点     | $O(n^2)$ | $O(n + m)$     | $O(n)$           |
| 内存空间占用 | $O(n^2)$ | $O(n + m)$     | $O(n + m)$       |

!!! note "时空权衡"

    即使邻接表（哈希表）各项操作的时间效率已经与邻接矩阵持平，但实际上并没有邻接矩阵快，这是因为在邻接矩阵中增删查「边」只需要一次数组访问或赋值操作。总结以上，邻接矩阵体现“以空间换时间”，邻接表体现“以时间换空间”。

## 图的实现

