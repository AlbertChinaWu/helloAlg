# 小结

- 输入 `key` ，哈希表能够在 $O(1)$ 时间内查询到 `value` ，效率非常高。
- 常见的哈希表操作包括查询、添加键值对、删除键值对和遍历哈希表等。
- 哈希函数将 `key` 映射为数组索引，从而访问对应桶并获取 `value` 。
- 两个不同的 `key` 可能在经过哈希函数后得到相同的数组索引，导致查询结果出错，这种现象被称为哈希冲突。
- 哈希表容量越大，哈希冲突的概率就越低。因此可以通过扩容哈希表来缓解哈希冲突。与数组扩容类似，哈希表扩容操作的开销很大。
- 负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。
- 链式地址通过将单个元素转化为链表，将所有冲突元素存储在同一个链表中。然而，链表过长会降低查询效率，可以进一步将链表转换为红黑树来提高效率。
- 开放寻址通过多次探测来处理哈希冲突。线性探测使用固定步长，缺点是不能删除元素，且容易产生聚集。多次哈希使用多个哈希函数进行探测，相较线性探测更不易产生聚集，但多个哈希函数增加了计算量。
- 不同编程语言采取了不同的哈希表实现。例如，Java 的 `HashMap` 使用链式地址，而 Python 的 `Dict` 采用开放寻址。
- 在哈希表中，我们希望哈希算法具有确定性、高效率和均匀分布的特点。在密码学中，哈希算法还应该具备抗碰撞性和雪崩效应。
- 哈希算法通常采用大质数作为模数，以最大化地保证哈希值的均匀分布，减少哈希冲突。
- 常见的哈希算法包括 MD5, SHA-1, SHA-2, SHA3 等。MD5 常用语校验文件完整性，SHA-2 常用于安全应用与协议。
- 编程语言通常会为数据类型提供内置哈希算法，用于计算哈希表中的桶索引。通常情况下，只有不可变对象是可哈希的。


## Q & A

!!! question "hash表的时间复杂度为啥是O(1)，不应该是O(n) 吗？"

    由于哈希冲突的存在，很有可能无法一次命中，因此哈希表的最差时间复杂度是 `O(n)` 当哈希函数设计的比较好、容量设置比较合理、冲突比较平均时，时间复杂度是 `O(1)` 我们一般使用哈希表无需关心底层工作方式，一律认为是 `O(1)` 。

!!! question "为什么不使哈希函数f(x) = x 呢？这样就不会有冲突了"

    `f(x) = x` 的情况与数组等价，即每个元素对应唯一的数组索引。换句话说，哈希表的目标是将一个较大的状态空间映射到一个较小的空间，并提供 O(1) 的查询效率。
    哈希表希望零冲突，但是无法做到，因为输入空间往往远远大于哈希表空间，所以哈希冲突无法被完全避免。换言之，我们希望的是哈希函数可以将冲突平均分布在每个桶内，最大化地保证查询效率。

!!! question "哈希表底层实现是数组、链表、二叉树，为什么效率可以更高呢？"
    
    1. 首先，哈希表的时间效率变高，$但空间效率变低了$。哈希表有相当一部分的内存是未使用的，相反地，链表则可根据需求来申请内存，数组虽然也有扩容机制导致的空间浪费，但和哈希表相比不是一个级别。
    2. 其次，$只是在特定使用场景下时间效率变高了$。如果一个功能能够在相同的时间复杂度下使用数组或链表实现，那么一般来说都是要比哈希表更快的。虽然时间复杂度都是，但哈希表各种操作更复杂（需要经过哈希函数），被化简的那个“常数项”更大。
    3. 最后，$哈希表的时间复杂度可能发生劣化$，例如在拉链法中，我们不得不在链表或红黑树种执行查找操作。在实际中，多多少少都会发生一点儿劣化，只是太难解决 + 影响不大而已。

!!! question "多次哈希有不能直接删除元素的缺陷吗？对于标记已删除的空间，这个空间还能再次使用吗？"
    
    多次哈希是开放寻址的一种，开放寻址法都会有不能直接删除元素的缺陷。但是可以通过标记删除的方式来间接删除元素。
    被标记为已删除的空间是可以再次被使用的。当新的元素需要插入哈希表，并且通过哈希函数找到了被标记为已删除的位置时，该位置可以被新的元素使用。这样做既能保持哈希表的探测序列不变，又能保证哈希表的空间使用率。

!!! question "为什么查找元素的时候也会出现哈希冲突呢？"
///线性探测中：“查找元素：若出现哈希冲突“。这里没太明白查找元素的时候怎么会出现冲突呢？ 输入一个key哈希函数的结果不是只有一个吗？！是插入的时候会把数组（桶）中已存在的的key的hash结果缓存，然后查找的时候先对比有冲突吗？
    
    查找的时候通过哈希函数找到第一个键值对，发现 key 对不上（代表有哈希冲突，正确的键值对在下面），就根据预先设定的步长依次向下查找～

!!! question "为什么哈希扩容也能解决哈希冲突？我们通过哈希函数得到索引，那不管这个数组有多大，一个key对应的索引也不会变吧，那这样扩容后不还是哈希冲突的吗"

    从整体上考虑，哈希函数会使得键值对尽量平均地分布在哈希表中，在扩容后也一样。也就是说，假设扩容前后键值对都是平均分布，但扩容后桶变多了，因此冲突就会减少。具体地看，哈希函数的最后一步往往是对数组长度 `n`取余，让输出值落入在数组索引范围；在扩容后，这个`n`也会变化，所以 key 对应的索引也会变化。